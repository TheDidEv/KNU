#include <iostream>
#include <map>
#include <set>
#include <vector>
#include <stack>
#include <algorithm>
#include <fstream>
#include <sstream>

using namespace std;
//?????????? ????????? ????? ?????
using ParsingTable = map<string, map<string, string>>;
using Productions = vector<string>;
using ParsingStack = stack<string>;

// ??????? ??? ?????????? ?????????
map<string, Productions> read_grammar() {
	map<string, Productions> grammar;// ????????? ????????????? ??????
	// ????????????? ?????????
	grammar["A"] = { "BC" };
	grammar["C"] = { "+BC", "?" };
	grammar["B"] = { "DE" };
	grammar["E"] = { "*DE", "?" };
	grammar["D"] = { "(A)", "i" };
	return grammar;
}

// ??????? ??? ?????????, ?? ?????? ? ??????????
bool is_terminal(const string& symbol) {
	// ?????????? ??????? ???????????? ????????
	const set<string> terminals = { "i", "+", "*", "(", ")", "?" };
	return terminals.find(symbol) != terminals.end();
}

bool ll1_parse(const string& input, const ParsingTable& table, const string& start_symbol) {
	ParsingStack parsingstack; // ???? ??? ????????? ???????
	parsingstack.push("$"); // ????????? ??????? ????? ???????? ? ????
	parsingstack.push(start_symbol); // ????????? ??????????? ??????? ????????? ? ????

	size_t input_pos = 0;
	while (!parsingstack.empty()) {// ???? ???????, ???? ???? ?? ????????
		string top = parsingstack.top(); // ????????? ????????? ???????? ?????
		parsingstack.pop(); // ????????? ????????? ???????? ?? ?????

		string current_input_symbol = (input_pos < input.size()) ? string(1, input[input_pos]) : "$"; // ?????????? ????????? ??????? ???????? ??? ?????????? ?? ??????
		cout << "Top of the stack: " << top << ", Current symbol: " << current_input_symbol << endl;

		// ?????? ??? ?????????? ????????? ???????? ????? ? ???????? ???????? ???????? ?? ????????? ???????
		if (top == "$" && current_input_symbol == "$") {
			continue; // ??????????? ??????, ???? ????????? ????? ????? ?? ????? ?????????
		}
		// ??????? ???????????? ????????
		else if (is_terminal(top)) {
			if (top == current_input_symbol) {
				input_pos++;
			}
			else {
				cout << "Terminal mismatch. Expected: " << top << ", Found: " << current_input_symbol << " - error" << endl;
				return false;
			}
		}
		// ??????? ?????????????? ????????
		else {
			auto inner_map = table.find(top);// ????? ? ??????? ???????
			if (inner_map != table.end()) {
				auto table_entry = inner_map->second.find(current_input_symbol);// ??????????? ???????????? ???????? ? ???????
				if (table_entry != inner_map->second.end()) {
					string production = table_entry->second;// ????????? ???????? ? ??????? ???????
					if (production != "?") {
						for (int i = production.size() - 1; i >= 0; i--) {
							parsingstack.push(string(1, production[i]));// ????????? ???????? production[i] ? ???? (????????? ???????)
						}
					}
				}
				else { // ?????????? ???????, ???? ????????? ????? ? ???????
					cout << "Parsing table doesn't have an entry for [" << top << ", " << current_input_symbol << "]" << " - error" << endl;
					return false;
				}
			}
			else {// ?????????? ???????, ???? ????????? ????? ? ???????
				cout << "Parsing table doesn't have an entry for [" << top << "]" << " - error" << endl;
				return false;
			}
		}
	}
	return input_pos == input.size();// ?????????? ?????????? ???????: true, ???? ???? ???? ??? ?????????? ???????, ?????? - false
}

// ??????? ??? ??????????? ????????????
set<string> epsilonNonTerminals(const map<string, Productions>& grammar) {
	map<string, bool> eps;  // ????????????? ???? ??? ??????????, ?? ? ?????????? ?
	for (const auto& rule : grammar) {// ???????? ?? ???????? ?????????
		eps[rule.first] = false; // ????????? ?????????? ???? ???????????? ?? ?????????? ??? ????????? ?
	}

	bool changed = true;
	while (changed) {
		changed = false;// ????????? ????????? ?? ?
		for (const auto& rule : grammar) {// ???????? ?? ???????? ?????????
			for (const string& production : rule.second) {
				bool allEpsilon = true;// ?????????, ?? ??????, ?? ??????? ??????? ????????? ?
				for (char ch : production) {
					if (is_terminal(string(1, ch)) || (!eps[string(1, ch)] && !is_terminal(string(1, ch)))) {
						allEpsilon = false;// ???? ???? ? ???? ?????? ?? ??????? ?, ?? ????????? ?? ??????? ?
						break;
					}
				}
				if (allEpsilon) {// ???? ????????? ??????? ?
					if (!eps[rule.first]) {// ???? ?????????? ?? ???????? ?????????? ?
						eps[rule.first] = true; // ?????????? ??????????? ?? ????????? ??? ????????? ?
						changed = true; // ??????? ??? ????? ??? ??????????? ????????
					}
				}
			}
		}
	}

	set<string> epsNonTerminals;// ????????? ??????? ??? ?????????? ?????????? ? ????????????
	// ???? ???? ????????????, ?? ?????? ?????????? ?
	for (const auto& item : eps) {// ???????? ?? ???? ? ?????????? ????????? ?
		if (item.second) {// ???? ?????????? ??????? ?
			epsNonTerminals.insert(item.first);// ????????? ??????????? ? ??????????? ?? ???????
		}
	}
	return epsNonTerminals; // ?????????? ??????? ????????????, ?? ?????? ?????????? ?
}

// ??????? ??? ?????????? First_k
map<string, set<string>> first_k(const map<string, Productions>& grammar, const set<string>& epsnonTerminals, int k) {
	map<string, set<string>> first_kSet;

	for (const auto& entry : grammar) {// ???????? ?? ???????? ?????????
		first_kSet[entry.first] = {};
	}

	bool changed = true;// ???? ??? ??????????? ????
	while (changed) {// ???? ???????????? ????? ? ???????? ?????? ????????
		changed = false;

		for (const auto& rule : grammar) {// ???????? ?? ???????? ?????????
			const string& non_terminal = rule.first;
			for (const string& production : rule.second) {// ???????? ?? ?????????? ??? ????????? ???????????
				vector<set<string>> first_kSymbols; // ?????? ??? ?????????? ?????? ?????? ???????? ??? ???????? ?????????

				for (char symbol : production) {// ???????? ?? ???????? ?????????
					if (is_terminal(string(1, symbol))) {
						first_kSymbols.push_back({ string(1, symbol) });// ????????? ????????????? ??????? ?? ??????? ?????? k ????????
					}
					else {
						first_kSymbols.push_back(first_kSet[string(1, symbol)]);// ????????? ??????? ?????? ???????? ??????????? ?? ??????? ?????? k ????????
					}
				}

				set<string> new_first_k;// ??????? ??? ??'??????? ?????? ???????? ?????????
				bool break_outer = false;

				for (int i = 0; i < first_kSymbols.size() && !break_outer; ++i) {// ???????? ?? ??????? ????????
					if (i == 0) {
						new_first_k = first_kSymbols[i];// ????????????? ????? ??????? ?????? k ????????
					}
					else {
						set<string> temp;// ????????? ??????? ??? ?????????? ??'??????? ????????
						for (const auto& a : new_first_k) {
							for (const auto& b : first_kSymbols[i]) {
								string combined = a + b;// ??'??????? ????????
								if (combined.size() > k) {
									combined = combined.substr(0, k);// ????????? ??????? ???????????? ???????? ?? k
								}
								temp.insert(combined); // ????????? ???????????? ???????? ?? ??????? ?????? k ????????
							}
						}
						new_first_k = temp;// ????????? ??????? ?????? ????????
					}

					if (epsnonTerminals.find(string(1, production[i])) == epsnonTerminals.end()) {
						break_outer = true; // ???? ?????? ?? ? ?-????????????, ???????? ? ??????????? ?????
					}
				}

				for (const string& item : new_first_k) {
					if (first_kSet[non_terminal].insert(item).second) {
						changed = true;// ??????? ??? ????? ??? ??????????? ????????
					}
				}
			}
		}
	}

	return first_kSet;
}

// ??????? ??? ?????????? Follow_k
map<string, set<string>> follow_k(const map<string, Productions>& grammar, const map<string, set<string>>& first_kSets, int k) {
	map<string, set<string>> follow_kSet;
	for (const auto& rule : grammar) {// ???????? ?? ???????? ?????????
		follow_kSet[rule.first] = {};// ????????????? ???? ??????????? k-?? ????? ??? ??????? ???????????
	}
	follow_kSet["A"].insert("$");// ????????? ??????? ????? ? ????????? ??????????

	bool changed = true;
	while (changed) {// ???? ???????????? ????? ? ???????? ???????????
		changed = false;
		for (const auto& rule : grammar) {// ???????? ?? ???????? ?????????
			for (const string& production : rule.second) {// ???????? ?? ?????????? ??? ????????? ???????????
				set<string> current_follow;
				for (int i = 0; production.size() >= i; i++) {// ???????? ?? ???????? ???????? ?????????
					char symbol = production[i];
					string symStr(1, symbol);
					if (is_terminal(symStr)) {// ???? ?????? ? ??????????
						current_follow = { symStr };// ????????????? ??????? ??????????? k-?? ????? ???????????? ????????
					}
					else {
						if (follow_kSet.find(symStr) != follow_kSet.end()) {// ???? ?????? ? ?????? ? ????
							follow_kSet[symStr].insert(current_follow.begin(), current_follow.end());
						}
						if (first_kSets.find(symStr) != first_kSets.end() && first_kSets.at(symStr).count("?")) { // ???? ?????? ??????? ?-?????????
							set<string> temp_first = first_kSets.at(symStr);
							temp_first.erase("?");// ????????? ? ? ??????? ???????
							current_follow.insert(temp_first.begin(), temp_first.end());
						}
						else if (first_kSets.find(symStr) != first_kSets.end()) {
							current_follow = first_kSets.at(symStr);// ?????????? ??????? ?????? ???????? ?? ???????
						}
					}
				}
			}
		}
	}
	return follow_kSet;
}

// ??????? ??? ???????? LL(k) ??????? ???????
ParsingTable build_parsing_table_k(const map<string, Productions>& grammar, const map<string, set<string>>& first_k, const map<string, set<string>>& follow_k, int k) {
	ParsingTable table;

	for (const auto& rule : grammar) { // ???????? ?? ???? ???????? ?????????
		const string& non_terminal = rule.first; // ????????? ????????? ???????????
		for (const string& production : rule.second) {
			set<string> first_of_production; // ????????????? ??????? ??? ?????????? ?????? ???????? 

			bool contains_epsilon = true; // ????????? ??? ????????? ????????? ?
			for (char symbol : production) {
				if (is_terminal(string(1, symbol))) { // ?????????, ?? ? ?????? ??????????
					first_of_production.insert(string(1, symbol)); // ????????? ????????????? ??????? ?? ??????? ?????? ????????
					contains_epsilon = false;
					break;
				}
				else {
					for (const string& terminal : first_k.at(string(1, symbol))) { // ????????? ?????? ???????? ????????????
						if (terminal != "?") {
							first_of_production.insert(terminal);
						}
					}
					if (first_k.at(string(1, symbol)).count("?") == 0) { // ????????? ????????? ? ? ??????? ???????
						contains_epsilon = false;
						break;
					}
				}
			}

			if (contains_epsilon) {
				first_of_production.insert("?"); // ????????? ? ?? ??????? ?????? ????????
			}

			for (const string& terminal : first_of_production) {
				if (terminal != "?") {
					table[non_terminal][terminal] = production; // ????? ? LL(k) ??????? ???????
				}
				else {
					for (const string& terminal_in_follow : follow_k.at(non_terminal)) {
						table[non_terminal][terminal_in_follow] = production; // ????? ???????? ? ??????? ??????????? k-?? ????? ? LL(k) ??????? ???????
					}
				}
			}
		}
	}

	return table;
}

int main() {
	auto grammar = read_grammar();
	auto epsilon_non_terminals = epsilonNonTerminals(grammar);
	int k = 2;
	auto first_kSet = first_k(grammar, epsilon_non_terminals, k);
	auto follow_kSet = follow_k(grammar, first_kSet, k);

	cout << "First:" << endl;
	for (const auto& item : follow_kSet) {
		cout << item.first << " = {";
		for (const string& val : item.second) {
			cout << " " << val;
		}
		cout << " }" << endl;
	}

	cout << "\nFollow:" << endl;
	for (const auto& item : follow_kSet) {
		cout << item.first << " = {";
		for (const string& val : item.second) {
			cout << " " << val;
		}
		cout << " }" << endl;
	}

	ParsingTable table = build_parsing_table_k(grammar, first_kSet, follow_kSet, k);
	table["U"]["+"] = "?";
	table["U"]["$"] = "?";
	table["U"][")"] = "?";
	table["F"][")"] = "?";
	table["F"]["$"] = "?";

	cout << "\nParsing Table:\n";
	for (const auto& row : table) {
		for (const auto& entry : row.second) {
			cout << "On [" << row.first << ", " << entry.first << "] apply: " << entry.second << "\n";
		}
	}

	vector<string> test_inputs = {
		"i+i*i",
		"i*i+i",
		"(i+i)*i",
		"i+(i+i)"
	};
	for (const string& test_input : test_inputs) {
		bool result = ll1_parse(test_input, table, "E");
		cout << "Parsing input '" << test_input << "': " << (result ? "SUCCESS" : "FAIL") << endl;
	}

	return 0;
}